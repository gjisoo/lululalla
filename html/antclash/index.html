<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ê°œë¯¸ì§‘ì§€í‚¤ê¸°</title>
<style>
  html,body {margin:0;padding:0;background:#0e0f12;color:#eee;font-family:system-ui,apple sd gothic neo,malgun gothic,sans-serif;}
  #wrap {position:fixed;inset:0;display:flex;flex-direction:column;}
  #topbar {display:flex;gap:8px;align-items:center;justify-content:space-between;padding:8px 12px;}
  #pher {font-weight:700}
  #game {flex:1;touch-action:none}
  #controls {
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:8px;
    padding:8px;
    background:#1a1c23; /* ë°°ê²½ìƒ‰ ì¶”ê°€ */
    position:fixed; /* ê³ ì • ìœ„ì¹˜ */
    bottom:0; /* í™”ë©´ í•˜ë‹¨ì— ê³ ì • */
    width:100%; /* í™”ë©´ ë„ˆë¹„ì— ë§ì¶¤ */
  }
  .btn {
    padding:10px 8px;
    border-radius:10px;
    border:none;
    background:#21242c;
    color:#fff;
    font-weight:700;
    cursor:grab; /* ë“œë˜ê·¸ ê°€ëŠ¥ í‘œì‹œ */
    background-size: 30px 30px;
    background-repeat: no-repeat;
    background-position: center top;
    padding-top: 40px;
  }
  .btn[data-card="tank"] {
    background-image: url('image/ant1.png');
  }
  .btn:active {transform:scale(0.98)}
  .hpbar{height:8px;background:#333;border-radius:8px;overflow:hidden}
  .hp{height:100%;background:#34d399}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div>ë‚´ ë‘¥ì§€ <div class="hpbar" style="width:120px"><div id="myhp" class="hp" style="width:100%"></div></div></div>
    <div id="pher">ğŸ§ª 0</div>
    <div>ìƒëŒ€ ë‘¥ì§€ <div class="hpbar" style="width:120px"><div id="aihp" class="hp" style="width:100%"></div></div></div>
  </div>
  <canvas id="game"></canvas>
  <div id="controls">
    <button class="btn" data-card="tank">íƒ±ì»¤(6)</button>
    <button class="btn" data-card="swarm">ë–¼(5)</button>
    <button class="btn" data-card="ranged">ì›ê±°ë¦¬(4)</button>
    <button class="btn" data-card="burst">ìŠ¤í‚¬(8)</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const pherEl = document.getElementById('pher');
  const myhpEl = document.getElementById('myhp');

  // --- CONFIG ---
  const world = { w: 540, h: 960 }; // ë…¼ë¦¬ í¬ê¸°(ì„¸ë¡œí˜•)
  const base = { my:{x: 240, y: 380, hp:100} }; // ê°œë¯¸ì§‘ ìœ„ì¹˜
  const regenPerSec = 2.2, pherCap = 10;
  const speed = { tank: 28, swarm: 42, ranged: 32 };
  const cost = { tank:6, swarm:5, ranged:4, burst:8 };
  const dmg = { tank: 7, swarm: 3, ranged: 5 };
  const range = { melee: 20, ranged: 140 };

  // --- PATH CONFIG ---
  const paths = [
    [{x: 0, y: 200}, {x: 100, y: 250}, {x: 180, y: 320}, {x: 240, y: 380}],
    [{x: 540, y: 300}, {x: 400, y: 340}, {x: 300, y: 360}, {x: 240, y: 380}],
    [{x: 270, y: 960}, {x: 260, y: 800}, {x: 250, y: 600}, {x: 240, y: 380}]
  ];

  // --- STATE ---
  let pher = 5, last = performance.now();
  const myUnits = [], aiUnits = [];
  const rnd = (a,b)=> a + Math.random()*(b-a);

  // --- ë°°ê²½ ì´ë¯¸ì§€ ---
  const background = new Image();
  background.src = 'image/ì¼ë³¸ì™•ê°œë¯¸ì§‘.png';

  // --- ê°œë¯¸ ì´ë¯¸ì§€ ---
  const antImages = {
    tank: new Image(),
    swarm: new Image(),
    ranged: new Image()
  };
  antImages.tank.src = 'image/ant1.png';

  // --- ë Œë”ë§ í¬ê¸°(í”½ì…€) ---
  // drawUnitì—ì„œ ì‚¬ìš©í•˜ëŠ” ì´ë¯¸ì§€/ë„í˜• í¬ê¸°ì™€ ë™ê¸°í™”í•˜ì„¸ìš”.
  const renderSize = {
    tank: 140,
    swarm: 100,
    ranged: 120
  };

  // --- RESIZE ---
  function fit() {
    const w = window.innerWidth, h = window.innerHeight;
    const scale = Math.min(w/world.w, h/world.h);
    const dpr = window.devicePixelRatio || 1;

    // CSS í¬ê¸° (í™”ë©´ì— ë³´ì´ëŠ” í¬ê¸°)
    canvas.style.width = Math.floor(world.w * scale) + 'px';
    canvas.style.height = Math.floor(world.h * scale) + 'px';

    // ë‚´ë¶€ ë¹„íŠ¸ë§µ í¬ê¸°(ë””ë°”ì´ìŠ¤ í”½ì…€ ë¹„ìœ¨ ì ìš©)
    canvas.width = Math.floor(world.w * scale * dpr);
    canvas.height = Math.floor(world.h * scale * dpr);

    // transformìœ¼ë¡œ ë…¼ë¦¬ ì¢Œí‘œê³„ ì„¤ì • (world í¬ê¸° ê¸°ì¤€)
    ctx.setTransform(scale * dpr, 0, 0, scale * dpr, 0, 0);

    // ì´ë¯¸ì§€ ìŠ¤ë¬´ë”© ì„¤ì • â€” ê³ í•´ìƒë„ì—ì„œ í’ˆì§ˆ ìš°ì„ 
    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch(e) {}
  }
  window.addEventListener('resize', fit, {passive:true});
  fit();

  // --- UNIT FACTORY ---
  function spawn(side, kind, pathIndex = 0) {
    if (side==='me' && pher < cost[kind]) return false;
    if (side==='me') pher -= cost[kind];
    const arr = side==='me'? myUnits: aiUnits;
    const path = paths[pathIndex % paths.length];
    const startPoint = side==='me' ? path[path.length - 1] : path[0]; // ìš°ë¦¬ëŠ” ì§‘ì—ì„œ, ì ì€ í™”ë©´ ëì—ì„œ
    const dir = side==='me'? 1 : -1;

    const common = { 
      side, 
      kind, 
      path: side==='me' ? [...path].reverse() : path, // ìš°ë¦¬ëŠ” ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ
      pathIndex: 0, 
      x: startPoint.x, 
      y: startPoint.y, 
      dir, 
      hp: 1, 
      cd: 0,
      hitEffect: 0, // ë¶€ë”ªíˆëŠ” ì´í™íŠ¸ ì‹œê°„
      facing: dir // ì´ˆê¹ƒê°’ìœ¼ë¡œ ë°”ë¼ë³´ëŠ” ë°©í–¥ ì €ì¥
    };
    if (kind==='tank') arr.push({...common, hp: 50});
    else if (kind==='swarm') {
      for (let i=0;i<6;i++) arr.push({...common, x: startPoint.x + rnd(-12,12), y: startPoint.y + rnd(-8,8), hp: 8});
    } else if (kind==='ranged') arr.push({...common, hp: 20, shoot: 0});
  }

  // --- INPUT ---
  const controls = document.getElementById('controls');
  let selectedCard = null;

  controls.querySelectorAll('.btn').forEach(btn => {
    // PCìš© ë“œë˜ê·¸ì•¤ë“œë¡­
    btn.setAttribute('draggable', 'true');
    btn.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('card', e.target.dataset.card);
    });

    // ëª¨ë°”ì¼ìš© í„°ì¹˜ ì´ë²¤íŠ¸
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      selectedCard = e.target.dataset.card;
      btn.style.transform = 'scale(0.95)';
      btn.style.background = '#3a3f4c';
    });

    btn.addEventListener('touchend', (e) => {
      btn.style.transform = '';
      btn.style.background = '#21242c';
    });

    // PCìš© í´ë¦­ ì´ë²¤íŠ¸
    btn.addEventListener('click', (e) => {
      selectedCard = e.target.dataset.card;
      btn.style.background = '#3a3f4c';
      setTimeout(() => {
        btn.style.background = '#21242c';
      }, 200);
    });
  });

  canvas.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  canvas.addEventListener('drop', (e) => {
    const card = e.dataTransfer.getData('card');
    if (!card) return;
    const pathIndex = Math.floor(Math.random() * paths.length);
    spawn('me', card, pathIndex);
  });

  // ëª¨ë°”ì¼ìš© í„°ì¹˜ ì´ë²¤íŠ¸
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (selectedCard) {
      const pathIndex = Math.floor(Math.random() * paths.length);
      spawn('me', selectedCard, pathIndex);
      selectedCard = null;
    }
  });

  // PCìš© í´ë¦­ ì´ë²¤íŠ¸
  canvas.addEventListener('click', (e) => {
    if (selectedCard) {
      const pathIndex = Math.floor(Math.random() * paths.length);
      spawn('me', selectedCard, pathIndex);
      selectedCard = null;
    }
  });

  // --- AI ì›¨ì´ë¸Œ ---
  let waveTimer = 0;
  function aiWave(dt) {
    waveTimer -= dt;
    if (waveTimer <= 0) {
      waveTimer = 5;
      for (let i = 0; i < paths.length; i++) {
        const pick = Math.random() < 0.5 ? 'tank' : 'swarm';
        spawn('ai', pick, i);
      }
    }
  }

  // --- COMBAT HELPERS ---
  function stepUnit(u, dt, foes) {
    const sp = u.kind==='tank'? speed.tank : u.kind==='ranged'? speed.ranged : speed.swarm;
    let target = null, dmin = 1e9;
    for (const f of foes) {
      const d = Math.hypot(f.x - u.x, f.y - u.y); // ê±°ë¦¬ ê³„ì‚°
      if (d < dmin) { dmin = d; target = f; }
    }
    const melee = (u.kind!=='ranged');
    const canHit = target && dmin <= (melee? range.melee : range.ranged);
    if (canHit) {
      u.cd -= dt;
      if (u.cd<=0) {
        u.cd = melee? 0.5 : 0.9;
        // ì´ë¯¸ì§€ ëê³¼ ëì´ ë‹¿ìœ¼ë©´ ì¶©ëŒ íŒì •
        const myRadius = (renderSize[u.kind] || 100) * 0.5; // ì´ë¯¸ì§€ ë°˜ì§€ë¦„
        const theirRadius = (renderSize[target.kind] || 100) * 0.5;
        const centerDist = Math.hypot(target.x - u.x, target.y - u.y);
        const touchDist = myRadius + theirRadius; // ì´ë¯¸ì§€ ëê³¼ ëì´ ë‹¿ëŠ” ê±°ë¦¬
        
        if (centerDist <= touchDist) {
          target.hp -= dmg[u.kind];
          // ë¶€ë”ªí˜ ì´í™íŠ¸ (í”ë“¤ë¦¼)
          u.hitEffect = 0.3; // 0.3ì´ˆ
          target.hitEffect = 0.3;
          
          // ì„œë¡œ ë°€ì–´ë‚´ëŠ” íš¨ê³¼ (íŒ…ê¸°ëŠ” íš¨ê³¼)
          const pushForce = 15; // ë°€ì–´ë‚´ëŠ” í˜
          const dx = target.x - u.x;
          const dy = target.y - u.y;
          const pushDist = Math.hypot(dx, dy);
          if (pushDist > 0) {
            const pushX = (dx / pushDist) * pushForce;
            const pushY = (dy / pushDist) * pushForce;
            // ê³µê²©ìëŠ” ë’¤ë¡œ, í”¼ê²©ìëŠ” ì•ìœ¼ë¡œ ë°€ë ¤ë‚¨
            u.x -= pushX * 0.3;
            u.y -= pushY * 0.3;
            target.x += pushX * 0.7;
            target.y += pushY * 0.7;
          }
        }
      }
      if (melee) return;
    } else {
      if (u.pathIndex < u.path.length) {
        const nextPoint = u.path[u.pathIndex];
        const dx = nextPoint.x - u.x;
        const dy = nextPoint.y - u.y;
        const dist = Math.hypot(dx, dy);
        
        // ì´ë™ ë°©í–¥ì— ë”°ë¥¸ facing ì—…ë°ì´íŠ¸
        if (Math.abs(dx) > 0.5) u.facing = dx < 0 ? -1 : 1;
        
        if (dist < 10) {
          u.pathIndex++;
          if (u.pathIndex >= u.path.length) {
            if (u.side === 'ai') {
              base.my.hp -= (u.kind==='tank'?8:4);
            }
            u.hp = 0;
          }
        } else {
          u.x += (dx / dist) * sp * dt * 60 / 100;
          u.y += (dy / dist) * sp * dt * 60 / 100;
        }
      }
    }
    if (u.side==='ai' && Math.hypot(u.x - base.my.x, u.y - base.my.y) <= 30) {
      base.my.hp -= (u.kind==='tank'?8:4); u.hp = 0;
    }
  }

  // --- GAME LOOP ---
  function loop(now) {
    const dt = Math.min(0.05, (now-last)/1000); last = now;
    pher = Math.min(pherCap, pher + regenPerSec*dt);
    pherEl.textContent = `ğŸ§ª ${Math.floor(pher)}`;
    aiWave(dt);
    for (const u of myUnits) stepUnit(u, dt, aiUnits);
    for (const u of aiUnits) stepUnit(u, dt, myUnits);
    for (let i=myUnits.length-1;i>=0;i--) if (myUnits[i].hp<=0) myUnits.splice(i,1);
    for (let i=aiUnits.length-1;i>=0;i--) if (aiUnits[i].hp<=0) aiUnits.splice(i,1);
    ctx.clearRect(0,0,world.w,world.h);

    // ë°°ê²½ ë Œë”ë§
    if (background.complete) {
      ctx.drawImage(background, 0, 0, world.w, world.h);
    }

    // ê²½ë¡œ ë Œë”ë§
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    paths.forEach(path => {
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    });

    // ë‘¥ì§€
    ctx.fillStyle = '#2a2f3c';
    ctx.beginPath(); ctx.arc(base.my.x, base.my.y, 28, 0, Math.PI*2); ctx.fill();

    function drawUnit(u){
      // ì´ë¯¸ì§€ì™€ HP ë°”ë¥¼ ë¶„ë¦¬í•´ ê·¸ë ¤ì„œ, ì´ë¯¸ì§€ë§Œ ì¢Œìš° ë°˜ì „ë˜ë„ë¡ í•¨
      // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
      ctx.save();
      ctx.translate(u.x, u.y);

      // ë¶€ë”ªíˆëŠ” ì´í™íŠ¸ (í”ë“¤ë¦¼)
      if (u.hitEffect && u.hitEffect > 0) {
        const shake = Math.sin(u.hitEffect * 40) * 3;
        ctx.translate(shake, 0);
        u.hitEffect -= dt;
      }

      // ì´ë™ ë°©í–¥ ê²°ì • (u.facingì€ stepUnitì—ì„œ ì—…ë°ì´íŠ¸ ë¨)
      const facing = (typeof u.facing !== 'undefined') ? u.facing : (u.dir || 1);

      // ê°œë¯¸ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ ë„í˜•
      if (antImages[u.kind] && antImages[u.kind].complete) {
        // í¬ê¸° ì¡°ê¸ˆ ì¤„ì„
        const size = u.kind==='tank'? 140 : (u.kind==='ranged'?120:100);
        if (facing === 1) ctx.scale(-1, 1); // ë°˜ì „ ì¡°ê±´ (í˜„ì¬ ì„¤ì •)
        ctx.drawImage(antImages[u.kind], -size/2, -size/2, size, size);
      } else {
        // ê¸°ë³¸ ë„í˜•
        ctx.fillStyle = (u.side==='me')? '#60a5fa' : '#f87171';
        const r = u.kind==='tank'? 45 : (u.kind==='ranged'?38:30);
        ctx.beginPath(); ctx.ellipse(0,0,r, r*0.7, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(r*0.9,0,r*0.4,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-r*0.9,0,r*0.5,0,Math.PI*2); ctx.fill();
      }

      ctx.restore();

      // HP ë°”ëŠ” ì´ë¯¸ì§€ ë°˜ì „ ì˜í–¥ì„ ë°›ì§€ ì•Šê²Œ ë³„ë„ë¡œ ê·¸ë¦¼
      ctx.save();
      ctx.translate(u.x, u.y);
      const hpw = Math.max(0, Math.min(1, u.hp/(u.kind==='tank'?50:(u.kind==='ranged'?20:8))))*18;
      ctx.fillStyle = '#10b981'; ctx.fillRect(-9,-14,hpw,3);
      ctx.restore();
    }
    myUnits.forEach(drawUnit); aiUnits.forEach(drawUnit);
    myhpEl.style.width = Math.max(0,base.my.hp)/100*100 + '%';
    if (base.my.hp<=0) {
      ctx.fillStyle = '#fff'; ctx.font = 'bold 36px system-ui';
      ctx.textAlign='center';
      ctx.fillText('íŒ¨ë°° ğŸ˜µ', world.w/2, world.h/2);
      return;
    }
    requestAnimationFrame(loop);
  }

  // ê²Œì„ ì‹œì‘
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
