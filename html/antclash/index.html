<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>개미집지키기</title>
<style>
  html,body {margin:0;padding:0;background:#0e0f12;color:#eee;font-family:system-ui,apple sd gothic neo,malgun gothic,sans-serif;}
  #wrap {position:fixed;inset:0;display:flex;flex-direction:column;}
  #topbar {display:flex;gap:8px;align-items:center;justify-content:space-between;padding:8px 12px;}
  #pher {font-weight:700}
  #game {flex:1;touch-action:none}
  #controls {
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:8px;
    padding:8px;
    background:#1a1c23; /* 배경색 추가 */
    position:fixed; /* 고정 위치 */
    bottom:0; /* 화면 하단에 고정 */
    width:100%; /* 화면 너비에 맞춤 */
  }
  .btn {
    padding:10px 8px;
    border-radius:10px;
    border:none;
    background:#21242c;
    color:#fff;
    font-weight:700;
    cursor:grab; /* 드래그 가능 표시 */
  }
  .btn:active {transform:scale(0.98)}
  .hpbar{height:8px;background:#333;border-radius:8px;overflow:hidden}
  .hp{height:100%;background:#34d399}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div>내 둥지 <div class="hpbar" style="width:120px"><div id="myhp" class="hp" style="width:100%"></div></div></div>
    <div id="pher">🧪 0</div>
    <div>상대 둥지 <div class="hpbar" style="width:120px"><div id="aihp" class="hp" style="width:100%"></div></div></div>
  </div>
  <canvas id="game"></canvas>
  <div id="controls">
    <button class="btn" data-card="tank">탱커(6)</button>
    <button class="btn" data-card="swarm">떼(5)</button>
    <button class="btn" data-card="ranged">원거리(4)</button>
    <button class="btn" data-card="burst">스킬(8)</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const pherEl = document.getElementById('pher');
  const myhpEl = document.getElementById('myhp');

  // --- CONFIG ---
  const world = { w: 540, h: 960 }; // 논리 크기(세로형)
  const base = { my:{x: 240, y: 380, hp:100} }; // 개미집 위치
  const regenPerSec = 2.2, pherCap = 10;
  const speed = { tank: 28, swarm: 42, ranged: 32 };
  const cost = { tank:6, swarm:5, ranged:4, burst:8 };
  const dmg = { tank: 7, swarm: 3, ranged: 5 };
  const range = { melee: 20, ranged: 140 };

  // --- PATH CONFIG ---
  const paths = [
    [{x: 0, y: 200}, {x: 100, y: 250}, {x: 180, y: 320}, {x: 240, y: 380}],
    [{x: 540, y: 300}, {x: 400, y: 340}, {x: 300, y: 360}, {x: 240, y: 380}],
    [{x: 270, y: 0}, {x: 260, y: 150}, {x: 250, y: 280}, {x: 240, y: 380}],
    [{x: 270, y: 960}, {x: 260, y: 800}, {x: 250, y: 600}, {x: 240, y: 380}]
  ];

  // --- STATE ---
  let pher = 5, last = performance.now();
  const myUnits = [], aiUnits = [];
  const rnd = (a,b)=> a + Math.random()*(b-a);

  // --- 배경 이미지 ---
  const background = new Image();
  background.src = 'image/일본왕개미집.png';

  // --- RESIZE ---
  function fit() {
    const w = window.innerWidth, h = window.innerHeight;
    const scale = Math.min(w/world.w, h/world.h);
    canvas.width = Math.floor(world.w*scale);
    canvas.height = Math.floor(world.h*scale);
    ctx.setTransform(scale,0,0,scale,0,0);
  }
  window.addEventListener('resize', fit, {passive:true});
  fit();

  // --- UNIT FACTORY ---
  function spawn(side, kind, pathIndex = 0) {
    if (side==='me' && pher < cost[kind]) return false;
    if (side==='me') pher -= cost[kind];
    const arr = side==='me'? myUnits: aiUnits;
    const path = paths[pathIndex % paths.length];
    const startPoint = side==='me' ? path[path.length - 1] : path[0]; // 우리는 집에서, 적은 화면 끝에서
    const dir = side==='me'? 1 : -1;

    const common = { 
      side, 
      kind, 
      path: side==='me' ? [...path].reverse() : path, // 우리는 반대 방향으로
      pathIndex: 0, 
      x: startPoint.x, 
      y: startPoint.y, 
      dir, 
      hp: 1, 
      cd: 0 
    };
    if (kind==='tank') arr.push({...common, hp: 50});
    else if (kind==='swarm') {
      for (let i=0;i<6;i++) arr.push({...common, x: startPoint.x + rnd(-12,12), y: startPoint.y + rnd(-8,8), hp: 8});
    } else if (kind==='ranged') arr.push({...common, hp: 20, shoot: 0});
  }

  // --- INPUT ---
  const controls = document.getElementById('controls');
  let selectedCard = null;

  controls.querySelectorAll('.btn').forEach(btn => {
    // PC용 드래그앤드롭
    btn.setAttribute('draggable', 'true');
    btn.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('card', e.target.dataset.card);
    });

    // 모바일용 터치 이벤트
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      selectedCard = e.target.dataset.card;
      btn.style.transform = 'scale(0.95)';
      btn.style.background = '#3a3f4c';
    });

    btn.addEventListener('touchend', (e) => {
      btn.style.transform = '';
      btn.style.background = '#21242c';
    });

    // PC용 클릭 이벤트
    btn.addEventListener('click', (e) => {
      selectedCard = e.target.dataset.card;
      btn.style.background = '#3a3f4c';
      setTimeout(() => {
        btn.style.background = '#21242c';
      }, 200);
    });
  });

  canvas.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  canvas.addEventListener('drop', (e) => {
    const card = e.dataTransfer.getData('card');
    if (!card) return;
    const pathIndex = Math.floor(Math.random() * paths.length);
    spawn('me', card, pathIndex);
  });

  // 모바일용 터치 이벤트
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (selectedCard) {
      const pathIndex = Math.floor(Math.random() * paths.length);
      spawn('me', selectedCard, pathIndex);
      selectedCard = null;
    }
  });

  // PC용 클릭 이벤트
  canvas.addEventListener('click', (e) => {
    if (selectedCard) {
      const pathIndex = Math.floor(Math.random() * paths.length);
      spawn('me', selectedCard, pathIndex);
      selectedCard = null;
    }
  });

  // --- AI 웨이브 ---
  let waveTimer = 0;
  function aiWave(dt) {
    waveTimer -= dt;
    if (waveTimer <= 0) {
      waveTimer = 5;
      for (let i = 0; i < paths.length; i++) {
        const pick = Math.random() < 0.5 ? 'tank' : 'swarm';
        spawn('ai', pick, i);
      }
    }
  }

  // --- COMBAT HELPERS ---
  function stepUnit(u, dt, foes) {
    const sp = u.kind==='tank'? speed.tank : u.kind==='ranged'? speed.ranged : speed.swarm;
    let target = null, dmin = 1e9;
    for (const f of foes) {
      const d = Math.hypot(f.x - u.x, f.y - u.y); // 거리 계산
      if (d < dmin) { dmin = d; target = f; }
    }
    const melee = (u.kind!=='ranged');
    const canHit = target && dmin <= (melee? range.melee : range.ranged);
    if (canHit) {
      u.cd -= dt;
      if (u.cd<=0) {
        u.cd = melee? 0.5 : 0.9;
        target.hp -= dmg[u.kind];
      }
      if (melee) return;
    } else {
      if (u.pathIndex < u.path.length) {
        const nextPoint = u.path[u.pathIndex];
        const dx = nextPoint.x - u.x;
        const dy = nextPoint.y - u.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist < 10) {
          u.pathIndex++;
          if (u.pathIndex >= u.path.length) {
            if (u.side === 'ai') {
              base.my.hp -= (u.kind==='tank'?8:4);
            }
            u.hp = 0;
          }
        } else {
          u.x += (dx / dist) * sp * dt * 60 / 100;
          u.y += (dy / dist) * sp * dt * 60 / 100;
        }
      }
    }
    if (u.side==='ai' && Math.hypot(u.x - base.my.x, u.y - base.my.y) <= 30) {
      base.my.hp -= (u.kind==='tank'?8:4); u.hp = 0;
    }
  }

  // --- GAME LOOP ---
  function loop(now) {
    const dt = Math.min(0.05, (now-last)/1000); last = now;
    pher = Math.min(pherCap, pher + regenPerSec*dt);
    pherEl.textContent = `🧪 ${Math.floor(pher)}`;
    aiWave(dt);
    for (const u of myUnits) stepUnit(u, dt, aiUnits);
    for (const u of aiUnits) stepUnit(u, dt, myUnits);
    for (let i=myUnits.length-1;i>=0;i--) if (myUnits[i].hp<=0) myUnits.splice(i,1);
    for (let i=aiUnits.length-1;i>=0;i--) if (aiUnits[i].hp<=0) aiUnits.splice(i,1);
    ctx.clearRect(0,0,world.w,world.h);

    // 배경 렌더링
    if (background.complete) {
      ctx.drawImage(background, 0, 0, world.w, world.h);
    }

    // 경로 렌더링
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    paths.forEach(path => {
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    });

    // 둥지
    ctx.fillStyle = '#2a2f3c';
    ctx.beginPath(); ctx.arc(base.my.x, base.my.y, 28, 0, Math.PI*2); ctx.fill();

    function drawUnit(u){
      ctx.save();
      ctx.translate(u.x, u.y);
      ctx.fillStyle = (u.side==='me')? '#60a5fa' : '#f87171';
      const r = u.kind==='tank'? 11 : (u.kind==='ranged'?9:7);
      ctx.beginPath(); ctx.ellipse(0,0,r, r*0.7, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(r*0.9,0,r*0.4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-r*0.9,0,r*0.5,0,Math.PI*2); ctx.fill();
      const hpw = Math.max(0, Math.min(1, u.hp/(u.kind==='tank'?50:(u.kind==='ranged'?20:8))))*18;
      ctx.fillStyle = '#10b981'; ctx.fillRect(-9,-14,hpw,3);
      ctx.restore();
    }
    myUnits.forEach(drawUnit); aiUnits.forEach(drawUnit);
    myhpEl.style.width = Math.max(0,base.my.hp)/100*100 + '%';
    if (base.my.hp<=0) {
      ctx.fillStyle = '#fff'; ctx.font = 'bold 36px system-ui';
      ctx.textAlign='center';
      ctx.fillText('패배 😵', world.w/2, world.h/2);
      return;
    }
    requestAnimationFrame(loop);
  }

  // 배경 이미지 로드 후 게임 시작
  background.onload = () => {
    requestAnimationFrame(loop);
  };
})();
</script>
</body>
</html>
