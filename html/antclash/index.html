<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>개미집지키기</title>
<style>
  html,body {margin:0;padding:0;background:#0e0f12;color:#eee;font-family:system-ui,apple sd gothic neo,malgun gothic,sans-serif;}
  #wrap {position:fixed;inset:0;display:flex;flex-direction:column;}
  #topbar {display:flex;gap:8px;align-items:center;justify-content:space-between;padding:8px 12px;}
  #pher {font-weight:700}
  #game {flex:1;touch-action:none}
  #controls {
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:8px;
    padding:8px;
    background:#1a1c23; /* 배경색 추가 */
    position:fixed; /* 고정 위치 */
    bottom:0; /* 화면 하단에 고정 */
    width:100%; /* 화면 너비에 맞춤 */
  }
  .btn {
    padding:10px 8px;
    border-radius:10px;
    border:none;
    background:#21242c;
    color:#fff;
    font-weight:700;
    cursor:grab; /* 드래그 가능 표시 */
    background-size: 30px 30px;
    background-repeat: no-repeat;
    background-position: center top;
    padding-top: 40px;
  }
  .btn[data-card="tank"] {
    background-image: url('image/ant1.png');
  }
  .btn:active {transform:scale(0.98)}
  .hpbar{height:8px;background:#333;border-radius:8px;overflow:hidden}
  .hp{height:100%;background:#34d399}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div>내 둥지 <div class="hpbar" style="width:120px"><div id="myhp" class="hp" style="width:100%"></div></div></div>
    <div id="pher">🧪 0</div>
    <div>상대 둥지 <div class="hpbar" style="width:120px"><div id="aihp" class="hp" style="width:100%"></div></div></div>
  </div>
  <canvas id="game"></canvas>
  <div id="controls">
    <button class="btn" data-card="tank">탱커(6)</button>
    <button class="btn" data-card="swarm">떼(5)</button>
    <button class="btn" data-card="ranged">원거리(4)</button>
    <button class="btn" data-card="burst">스킬(8)</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const pherEl = document.getElementById('pher');
  const myhpEl = document.getElementById('myhp');

  // --- CONFIG ---
  const world = { w: 540, h: 960 }; // 논리 크기(세로형)
  const base = { my:{x: 240, y: 380, hp:100} }; // 개미집 위치
  const regenPerSec = 2.2, pherCap = 10;
  const speed = { tank: 28, swarm: 42, ranged: 32 };
  const cost = { tank:6, swarm:5, ranged:4, burst:8 };
  const dmg = { tank: 7, swarm: 3, ranged: 5 };
  const range = { melee: 20, ranged: 140 };

  // --- PATH CONFIG ---
  const paths = [
    [{x: 0, y: 200}, {x: 100, y: 250}, {x: 180, y: 320}, {x: 240, y: 380}],
    [{x: 540, y: 300}, {x: 400, y: 340}, {x: 300, y: 360}, {x: 240, y: 380}],
    [{x: 270, y: 960}, {x: 260, y: 800}, {x: 250, y: 600}, {x: 240, y: 380}]
  ];

  // --- STATE ---
  let pher = 5, last = performance.now();
  const myUnits = [], aiUnits = [];
  const rnd = (a,b)=> a + Math.random()*(b-a);

  // --- 배경 이미지 ---
  const background = new Image();
  background.src = 'image/일본왕개미집.png';

  // --- 개미 이미지 ---
  const antImages = {
    tank: new Image(),
    swarm: new Image(),
    ranged: new Image()
  };
  antImages.tank.src = 'image/ant1.png';

  // --- 렌더링 크기(픽셀) ---
  // drawUnit에서 사용하는 이미지/도형 크기와 동기화하세요.
  const renderSize = {
    tank: 140,
    swarm: 100,
    ranged: 120
  };

  // --- RESIZE ---
  function fit() {
    const w = window.innerWidth, h = window.innerHeight;
    const scale = Math.min(w/world.w, h/world.h);
    const dpr = window.devicePixelRatio || 1;

    // CSS 크기 (화면에 보이는 크기)
    canvas.style.width = Math.floor(world.w * scale) + 'px';
    canvas.style.height = Math.floor(world.h * scale) + 'px';

    // 내부 비트맵 크기(디바이스 픽셀 비율 적용)
    canvas.width = Math.floor(world.w * scale * dpr);
    canvas.height = Math.floor(world.h * scale * dpr);

    // transform으로 논리 좌표계 설정 (world 크기 기준)
    ctx.setTransform(scale * dpr, 0, 0, scale * dpr, 0, 0);

    // 이미지 스무딩 설정 — 고해상도에서 품질 우선
    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch(e) {}
  }
  window.addEventListener('resize', fit, {passive:true});
  fit();

  // --- UNIT FACTORY ---
  function spawn(side, kind, pathIndex = 0) {
    if (side==='me' && pher < cost[kind]) return false;
    if (side==='me') pher -= cost[kind];
    const arr = side==='me'? myUnits: aiUnits;
    const path = paths[pathIndex % paths.length];
    const startPoint = side==='me' ? path[path.length - 1] : path[0]; // 우리는 집에서, 적은 화면 끝에서
    const dir = side==='me'? 1 : -1;

    const common = { 
      side, 
      kind, 
      path: side==='me' ? [...path].reverse() : path, // 우리는 반대 방향으로
      pathIndex: 0, 
      x: startPoint.x, 
      y: startPoint.y, 
      dir, 
      hp: 1, 
      cd: 0,
      hitEffect: 0, // 부딪히는 이펙트 시간
      facing: dir // 초깃값으로 바라보는 방향 저장
    };
    if (kind==='tank') arr.push({...common, hp: 50});
    else if (kind==='swarm') {
      for (let i=0;i<6;i++) arr.push({...common, x: startPoint.x + rnd(-12,12), y: startPoint.y + rnd(-8,8), hp: 8});
    } else if (kind==='ranged') arr.push({...common, hp: 20, shoot: 0});
  }

  // --- INPUT ---
  const controls = document.getElementById('controls');
  let selectedCard = null;

  controls.querySelectorAll('.btn').forEach(btn => {
    // PC용 드래그앤드롭
    btn.setAttribute('draggable', 'true');
    btn.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('card', e.target.dataset.card);
    });

    // 모바일용 터치 이벤트
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      selectedCard = e.target.dataset.card;
      btn.style.transform = 'scale(0.95)';
      btn.style.background = '#3a3f4c';
    });

    btn.addEventListener('touchend', (e) => {
      btn.style.transform = '';
      btn.style.background = '#21242c';
    });

    // PC용 클릭 이벤트
    btn.addEventListener('click', (e) => {
      selectedCard = e.target.dataset.card;
      btn.style.background = '#3a3f4c';
      setTimeout(() => {
        btn.style.background = '#21242c';
      }, 200);
    });
  });

  canvas.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  canvas.addEventListener('drop', (e) => {
    const card = e.dataTransfer.getData('card');
    if (!card) return;
    const pathIndex = Math.floor(Math.random() * paths.length);
    spawn('me', card, pathIndex);
  });

  // 모바일용 터치 이벤트
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (selectedCard) {
      const pathIndex = Math.floor(Math.random() * paths.length);
      spawn('me', selectedCard, pathIndex);
      selectedCard = null;
    }
  });

  // PC용 클릭 이벤트
  canvas.addEventListener('click', (e) => {
    if (selectedCard) {
      const pathIndex = Math.floor(Math.random() * paths.length);
      spawn('me', selectedCard, pathIndex);
      selectedCard = null;
    }
  });

  // --- AI 웨이브 ---
  let waveTimer = 0;
  function aiWave(dt) {
    waveTimer -= dt;
    if (waveTimer <= 0) {
      waveTimer = 5;
      for (let i = 0; i < paths.length; i++) {
        const pick = Math.random() < 0.5 ? 'tank' : 'swarm';
        spawn('ai', pick, i);
      }
    }
  }

  // --- COMBAT HELPERS ---
  function stepUnit(u, dt, foes) {
    const sp = u.kind==='tank'? speed.tank : u.kind==='ranged'? speed.ranged : speed.swarm;
    let target = null, dmin = 1e9;
    for (const f of foes) {
      const d = Math.hypot(f.x - u.x, f.y - u.y); // 거리 계산
      if (d < dmin) { dmin = d; target = f; }
    }
    const melee = (u.kind!=='ranged');
    const canHit = target && dmin <= (melee? range.melee : range.ranged);
    if (canHit) {
      u.cd -= dt;
      if (u.cd<=0) {
        u.cd = melee? 0.5 : 0.9;
        // 이미지 끝과 끝이 닿으면 충돌 판정
        const myRadius = (renderSize[u.kind] || 100) * 0.5; // 이미지 반지름
        const theirRadius = (renderSize[target.kind] || 100) * 0.5;
        const centerDist = Math.hypot(target.x - u.x, target.y - u.y);
        const touchDist = myRadius + theirRadius; // 이미지 끝과 끝이 닿는 거리
        
        if (centerDist <= touchDist) {
          target.hp -= dmg[u.kind];
          // 부딪힘 이펙트 (흔들림)
          u.hitEffect = 0.3; // 0.3초
          target.hitEffect = 0.3;
          
          // 서로 밀어내는 효과 (팅기는 효과)
          const pushForce = 15; // 밀어내는 힘
          const dx = target.x - u.x;
          const dy = target.y - u.y;
          const pushDist = Math.hypot(dx, dy);
          if (pushDist > 0) {
            const pushX = (dx / pushDist) * pushForce;
            const pushY = (dy / pushDist) * pushForce;
            // 공격자는 뒤로, 피격자는 앞으로 밀려남
            u.x -= pushX * 0.3;
            u.y -= pushY * 0.3;
            target.x += pushX * 0.7;
            target.y += pushY * 0.7;
          }
        }
      }
      if (melee) return;
    } else {
      if (u.pathIndex < u.path.length) {
        const nextPoint = u.path[u.pathIndex];
        const dx = nextPoint.x - u.x;
        const dy = nextPoint.y - u.y;
        const dist = Math.hypot(dx, dy);
        
        // 이동 방향에 따른 facing 업데이트
        if (Math.abs(dx) > 0.5) u.facing = dx < 0 ? -1 : 1;
        
        if (dist < 10) {
          u.pathIndex++;
          if (u.pathIndex >= u.path.length) {
            if (u.side === 'ai') {
              base.my.hp -= (u.kind==='tank'?8:4);
            }
            u.hp = 0;
          }
        } else {
          u.x += (dx / dist) * sp * dt * 60 / 100;
          u.y += (dy / dist) * sp * dt * 60 / 100;
        }
      }
    }
    if (u.side==='ai' && Math.hypot(u.x - base.my.x, u.y - base.my.y) <= 30) {
      base.my.hp -= (u.kind==='tank'?8:4); u.hp = 0;
    }
  }

  // --- GAME LOOP ---
  function loop(now) {
    const dt = Math.min(0.05, (now-last)/1000); last = now;
    pher = Math.min(pherCap, pher + regenPerSec*dt);
    pherEl.textContent = `🧪 ${Math.floor(pher)}`;
    aiWave(dt);
    for (const u of myUnits) stepUnit(u, dt, aiUnits);
    for (const u of aiUnits) stepUnit(u, dt, myUnits);
    for (let i=myUnits.length-1;i>=0;i--) if (myUnits[i].hp<=0) myUnits.splice(i,1);
    for (let i=aiUnits.length-1;i>=0;i--) if (aiUnits[i].hp<=0) aiUnits.splice(i,1);
    ctx.clearRect(0,0,world.w,world.h);

    // 배경 렌더링
    if (background.complete) {
      ctx.drawImage(background, 0, 0, world.w, world.h);
    }

    // 경로 렌더링
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    paths.forEach(path => {
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    });

    // 둥지
    ctx.fillStyle = '#2a2f3c';
    ctx.beginPath(); ctx.arc(base.my.x, base.my.y, 28, 0, Math.PI*2); ctx.fill();

    function drawUnit(u){
      // 이미지와 HP 바를 분리해 그려서, 이미지만 좌우 반전되도록 함
      // 이미지 그리기
      ctx.save();
      ctx.translate(u.x, u.y);

      // 부딪히는 이펙트 (흔들림)
      if (u.hitEffect && u.hitEffect > 0) {
        const shake = Math.sin(u.hitEffect * 40) * 3;
        ctx.translate(shake, 0);
        u.hitEffect -= dt;
      }

      // 이동 방향 결정 (u.facing은 stepUnit에서 업데이트 됨)
      const facing = (typeof u.facing !== 'undefined') ? u.facing : (u.dir || 1);

      // 개미 이미지가 있으면 이미지 사용, 없으면 기본 도형
      if (antImages[u.kind] && antImages[u.kind].complete) {
        // 크기 조금 줄임
        const size = u.kind==='tank'? 140 : (u.kind==='ranged'?120:100);
        if (facing === 1) ctx.scale(-1, 1); // 반전 조건 (현재 설정)
        ctx.drawImage(antImages[u.kind], -size/2, -size/2, size, size);
      } else {
        // 기본 도형
        ctx.fillStyle = (u.side==='me')? '#60a5fa' : '#f87171';
        const r = u.kind==='tank'? 45 : (u.kind==='ranged'?38:30);
        ctx.beginPath(); ctx.ellipse(0,0,r, r*0.7, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(r*0.9,0,r*0.4,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-r*0.9,0,r*0.5,0,Math.PI*2); ctx.fill();
      }

      ctx.restore();

      // HP 바는 이미지 반전 영향을 받지 않게 별도로 그림
      ctx.save();
      ctx.translate(u.x, u.y);
      const hpw = Math.max(0, Math.min(1, u.hp/(u.kind==='tank'?50:(u.kind==='ranged'?20:8))))*18;
      ctx.fillStyle = '#10b981'; ctx.fillRect(-9,-14,hpw,3);
      ctx.restore();
    }
    myUnits.forEach(drawUnit); aiUnits.forEach(drawUnit);
    myhpEl.style.width = Math.max(0,base.my.hp)/100*100 + '%';
    if (base.my.hp<=0) {
      ctx.fillStyle = '#fff'; ctx.font = 'bold 36px system-ui';
      ctx.textAlign='center';
      ctx.fillText('패배 😵', world.w/2, world.h/2);
      return;
    }
    requestAnimationFrame(loop);
  }

  // 게임 시작
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
